import L from "thing-engine/js/utils/l.js";
import Lib from "thing-engine/js/lib.js";

function sortObject(obj) {
	let ret = {};
	Object.keys(obj).sort().some((name) => {
		ret[name] = obj[name];
	});
	return ret;
}

export default class Build {
	static build(debug) {
		
		let scenes = sortObject(Lib._getAllScenes());
		let prefabs = sortObject(Lib._getAllPrefabs());
		
		let images = Lib.__texturesList.filter(n => n.value !== 'EMPTY' && n.value !== 'WHITE').map((t) => {
			return t.value;
		});
		images = images.slice().sort();

		let resources;
		for(let r in Lib.resources) {
			if(!resources) {
				resources = [];
			}
			resources.push(r);
		}
		if(resources) {
			resources.sort();
		}
		
		let fileSavePromises = [];

		let sounds = Lib.__getSoundsData();
		/*
		let version = editor.projectDesc.version.split('.');
		let latest = parseInt(version.pop());
		latest++;
		version.push(latest);
		editor.projectDesc.version = version.join('.');
		editor.saveProjectDesc();*/

		let projectDesc = Object.assign({}, editor.projectDesc);
		delete projectDesc.lastSceneName;

		let assetsObj = {scenes, prefabs, images, resources, sounds, projectDesc};
		if(editor.projectDesc.embedLocales) {
			assetsObj.text = L.__getTextAssets();
		}

		fileSavePromises.push(editor.fs.saveFile('assets.js', 'window._thingEngineAssest = ' + JSON.stringify(assetsObj, null, '	') + ';'));
		

		let classesSrc = editor.ClassesLoader.gameObjClasses.concat(editor.ClassesLoader.sceneClasses);
		let src = [`/* this file is generated by thing-editor.
Please do not modify it. Any changes will be owerriden anyway.*/

import Lib from "thing-engine/js/lib.js";
let classes = {};`];
		let defaults = {};
		
		for(let c of classesSrc) {
			let name = c.c.name;
			let path = editor.ClassesLoader.getClassPath(name);
			if(path) {

				if(path.startsWith('/')) {
					path = path.substr(1);
				}

				if(findClassNameInData(name, scenes) || findClassNameInData(name, prefabs)) { //only referenced classes
					src.push('import ' + name + ' from "' + path + '";');
					src.push('classes["' + name + '"] = ' + name + ';');
					defaults[name] = editor.ClassesLoader.classesDefaultsById[name];
				}
			}
		}
		src.push('Lib._setClasses(classes, ');
		src.push(JSON.stringify(defaults, null, ' ') + ');');
		fileSavePromises.push(editor.fs.saveFile('src/classes.js', src.join('\n')));
		
		Promise.all(fileSavePromises).then(() => {
			editor.fs.getJSON('/fs/build' + (debug ? '?debug=1' : '')).then((result) => {
				
				if(result.errors.length > 0) {
					editor.ui.modal.showError(result.errors.map((r, i) =>{
						return R.div({key:i}, r);
					}));
				} else {
					
					if(result.warnings.length > 0) {
						editor.ui.modal.showModal(result.warnings.map((r, i) =>{
							return R.div({key:i}, r);
						}));
					}
					
					window.open('/games/' + editor.currentProjectDir + (debug ? 'debug' : 'release'));
				}
			});
		});
	}
}

function findClassNameInData(name, data) {
	for(let prefabName in data) {
		if(findClassNameInPrefabData(name, data[prefabName])) return true;
	}
}

function findClassNameInPrefabData(name, data) {
	if(data.c === name) {
		return true;
	}
	if(data.hasOwnProperty(':')){
		return data[':'].some((d) => {
			return findClassNameInPrefabData(name, d);
		});
	}
}
